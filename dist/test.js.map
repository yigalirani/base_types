{
  "version": 3,
  "sources": ["../src/test.ts", "../src/index.ts"],
  "sourcesContent": ["import { \n  is_object, \n  pk, \n  run_tests, \n  type Test, \n  is_string_array, \n  sleep,\n  is_promise,\n  resolve_maybe_promise,\n  getCommonPrefix,\n  default_get,\n  has_keys,\n  has_key,\n  is_atom,\n  is_key,\n  nl,\n  get_error,\n  objects_only\n} from './index'\n\nclass Hello{\n  constructor(){\n    console.log('making Hello')\n  }\n}\nfunction createSimplePromise(shouldSucceed: boolean): Promise<string> {\n  return new Promise((resolve, reject) => {\n    // Simulate an asynchronous operation, e.g., a network request or a timer\n    setTimeout(() => {\n      if (shouldSucceed) {\n        resolve(\"Operation successful!\"); // Resolve the promise with a success value\n      } else {\n        reject(new Error(\"Operation failed!\")); // Reject the promise with an error\n      }\n    }, 1000); // Simulate a 1-second delay\n  });\n}  \ntype UserOpt = { id: number; name?: string }\n\n// Test function to run all tests\nasync function testSleep() {\n  console.log(\"Test started...\");\n\n  const start = Date.now();\n  await sleep(1000); // sleep for 1 second\n  const end = Date.now();\n\n  console.log(`Slept for ${end - start} ms`);\n  console.log(\"Test finished.\");\n  return Math.abs(end-start-1000)<100\n}\n\nexport async function runTests() {\n  const tests:Test[]=[\n  {k:'class instance',f:()=> is_object(new Hello())},\n  {k:'Set',v:false,f:()=> is_object(new Set())},\n  {k:'Function',f:()=> is_object(() => {})},\n  {k:'Array',v:false,f:()=> is_object([1, 2, 3])},\n  {k:'Number atom',v:false,f:()=> is_object(42)},\n  {k:'String atom',v:false,f:()=> is_object('hello')},\n  {k:'Boolean atom',f:()=> !is_object(true)},\n  {k:'null',v:false,f:()=> is_object(null)},\n  {k:'undefined',v:false,f:()=> is_object(undefined)},\n  {k:'Date',f:()=> is_object(new Date())},\n  {k:'RegExp',f:()=> is_object(/test/)},\n  {k:'Map',v:false,f:()=> is_object(new Map())},\n  {k:'Promise',f:()=> is_object(createSimplePromise(true))},\n  // Test cases that should return true\n  {k:'Plain object',f:()=> is_object({})},\n  {k:'Plain object with properties',f:()=> is_object({ a: 1, b: 'test' })},\n  {k:'Object created with Object.create',f:()=> is_object(Object.create({}))},\n  {k:'pk picks single key',f:()=>{\n    const user = { id: 7, name: 'Ada', active: true }\n    const pickId = pk(user, 'id')\n    return pickId.id === 7\n  }},\n  {k:'pk picks multiple keys', f:()=>{\n    const user = { id: 7, name: 'Ada', active: true }\n    const pickTwo = pk(user, 'id', 'name')\n    return pickTwo.id === 7 && pickTwo.name === 'Ada'\n  }},\n  {k:'pk returns undefined for missing optional key',f:()=>{\n    const userOpt: UserOpt = { id: 1 }\n    const pickOptional = pk(userOpt, 'name')\n    return pickOptional.name === undefined\n  }},\n  {k:'pk works with undefined source, values undefined',f:()=>{\n    const pickFromUndefined = pk<UserOpt, 'id' | 'name'>(undefined, 'id', 'name')    \n    return pickFromUndefined.id === undefined && pickFromUndefined.name === undefined\n  }},\n  {v:false,f:()=>is_string_array(null)},\n  {v:false,f:()=>is_string_array({})},\n  {v:true,f:()=>is_string_array([])},\n  {v:true,f:()=>is_string_array(['hello'])},\n  {v:true,f:()=>is_string_array(['hello','1'])},\n  {v:false,f:()=>is_string_array(['hello',1])},\n  {v:true,f:testSleep},\n  // is_promise tests\n  {k:'is_promise with Promise',f:()=>is_promise(createSimplePromise(true))},\n  {k:'is_promise with non-Promise object',v:false,f:()=>is_promise({})},\n  {k:'is_promise with thenable object',f:()=>is_promise({then:()=>{}})},\n  {k:'is_promise with null',v:false,f:()=>is_promise(null)},\n  {k:'is_promise with string',v:false,f:()=>is_promise('test')},\n  // resolve_maybe_promise tests\n  {k:'resolve_maybe_promise with value',f:async()=>{\n    const result = await resolve_maybe_promise(42)\n    return result === 42\n  }},\n  {k:'resolve_maybe_promise with Promise',f:async()=>{\n    const result = await resolve_maybe_promise(Promise.resolve('success'))\n    return result === 'success'\n  }},\n  // getCommonPrefix tests\n  {k:'getCommonPrefix empty array',f:()=>getCommonPrefix([])===''},\n  {k:'getCommonPrefix single path',f:()=>getCommonPrefix(['a/b/c'])==='a/b/c'},\n  {k:'getCommonPrefix common prefix',f:()=>getCommonPrefix(['a/b/c','a/b/d'])==='a/b'},\n  {k:'getCommonPrefix no common prefix',f:()=>getCommonPrefix(['a/b','c/d'])===''},\n  {k:'getCommonPrefix windows paths',f:()=>getCommonPrefix(['a\\\\b\\\\c','a\\\\b\\\\d'])==='a/b'},\n  // default_get tests\n  {k:'default_get existing key',f:()=>{\n    const obj = {a:1}\n    return default_get(obj,'a',()=>2) === 1\n  }},\n  {k:'default_get missing key',f:()=>{\n    const obj:Record<string,number> = {}\n    const result = default_get(obj,'a',()=>42)\n    return result === 42 && obj.a === 42\n  }},\n  // has_keys tests\n  {v:false,k:'has_keys with matching key',f:()=>has_keys({a:1,b:2},['a','c'])},\n  {k:'has_keys with no matching key',v:false,f:()=>has_keys({a:1,b:2},['c','d'])},\n  {k:'has_keys with non-object',v:false,f:()=>has_keys(null,['a'])},\n  // has_key tests\n  {k:'has_key with existing key',f:()=>has_key({a:1},'a')},\n  {k:'has_key with missing key',v:false,f:()=>has_key({a:1},'b')},\n  {k:'has_key with non-object',v:false,f:()=>has_key(null,'a')},\n  // is_atom tests\n  {k:'is_atom with number',f:()=>is_atom(42)},\n  {k:'is_atom with string',f:()=>is_atom('hello')},\n  {k:'is_atom with boolean',f:()=>is_atom(true)},\n  {k:'is_atom with null',v:false,f:()=>is_atom(null)},\n  {k:'is_atom with object',v:false,f:()=>is_atom({})},\n  // is_key tests\n  {k:'is_key with number',f:()=>is_key(42)},\n  {k:'is_key with string',f:()=>is_key('hello')},\n  {k:'is_key with boolean',v:false,f:()=>is_key(true)},\n  {k:'is_key with null',v:false,f:()=>is_key(null)},\n  // nl tests\n  {k:'nl with value',f:()=>nl(42)===42},\n  {k:'nl with null throws',f:()=>{\n    try {\n      nl(null)\n      return false\n    } catch {\n      return true\n    }\n  }},\n  {k:'nl with undefined throws',f:()=>{\n    try {\n      nl(undefined)\n      return false\n    } catch {\n      return true\n    }\n  }},\n  // get_error tests\n  {k:'get_error with Error',f:()=>get_error(new Error('test')) instanceof Error},\n  {k:'get_error with string',f:()=>get_error('test') instanceof Error},\n  {k:'get_error with number',f:()=>get_error(42) instanceof Error},\n  // objects_only tests\n  {k:'objects_only filters objects',f:()=>{\n    const arr = [1,{a:1},'test',{b:2},null]\n    const objects = Array.from(objects_only(arr))\n    return objects.length === 2 && objects[0].a === 1 && objects[1].b === 2\n  }}\n  ]\n  await run_tests(...tests)\n}\n\n// Run tests if this file is executed directly\nif (typeof require !== 'undefined' && require.main === module) {\n  void runTests()\n}\n\n\n", "export type s2t<T> = Record<string, T>\nexport type s2u = Record<string, unknown>\nexport type p2u = Record<PropertyKey, unknown> \nexport const green='\\x1b[40m\\x1b[32m'\nexport const red='\\x1b[40m\\x1b[31m'\nexport const yellow='\\x1b[40m\\x1b[33m'\n\nexport const reset='\\x1b[0m'\nexport function nl<T>(value: T | null | undefined): T {\n  //todo:check only active on debug mode\n  //return value\n  if (value === null || value === undefined) {\n    throw new Error('Value cannot be null or undefined')\n  }\n  return value\n}\nexport type Key = number | string //should i use properykey for this?\nexport type Atom = number | string | boolean \nexport function is_atom(x: unknown): x is Atom {\n  if (x == null) return false\n  return ['number', 'string', 'boolean'].includes(typeof x)\n}\nexport function is_key(x: unknown): x is Key {\n  if (x == null) return false\n  return ['number', 'string'].includes(typeof x)\n}\nexport function is_atom_ex(v: unknown, place: string, k = ''): v is Atom {\n  if (is_atom(v)) return true\n  console.warn('non-atom', place, k, v)\n  return false\n}\nexport function get_error(x:unknown){\n  if (x instanceof Error)\n    return x\n  const str = String(x)\n  return new Error(str)\n}\nexport function is_object<T extends object=s2u>(value: unknown): value is T{\n  if (value == null) return false;\n  \n  // Accept objects and functions\n  if (typeof value !== 'object' && typeof value !== 'function') return false;\n  \n  // Exclude known non-object types\n  if (Array.isArray(value)) return false;\n  if (value instanceof Set) return false;\n  if (value instanceof Map) return false;\n  \n  return true;\n}\nexport function has_key(obj: unknown, k: string): boolean {\n  if (!is_object(obj)) return false\n  return k in obj\n}\nexport function* objects_only(ar:unknown[]){\n  for (const item of ar)\n    if (is_object(item))\n      yield item\n}\n\nexport function has_keys(obj: unknown, keys: string[]): boolean {\n  if (!is_object(obj)) return false\n  for (const k of keys) if (k in keys) return true\n  return false\n}\nexport type strset = Set<string>\nexport type s2num = Record<string, number>\nexport type s2s = Record<string, string>\nexport type num2num = Record<number, number>\n\nexport function pk<T, K extends keyof T>(obj: T | undefined, ...keys: K[]): Pick<T, K> {\n  const ret: Record<PropertyKey,unknown> = {} \n  keys.forEach((key) => {\n    ret[key] = obj?.[key]\n  })\n  return ret as Pick<T, K> \n}\nexport function is_promise<T=void>(value: unknown): value is Promise<T> { ///ts(2677)\n  if (!is_object(value))\n    return false\n\n  const ans=typeof (value.then)==='function'\n  return ans\n}\nexport type MaybePromise<T>=T|Promise<T>\nexport async function resolve_maybe_promise<T>(a:MaybePromise<T>){\n  if (is_promise(a))\n    return await a\n  return a\n}\n      \nexport interface Test{\n  k?:string,\n  v?:Atom,\n  f:()=>MaybePromise<Atom>\n}\n\nexport async function run_tests(...tests: Test[]) {\n  let passed = 0\n  let failed = 0\n  \n  for (const {k,v,f} of tests) {\n    const ek=function(){\n      if (k!=null)\n        return k\n      const fstr=String(f)\n      {\n        const match=fstr.match(/(\\(\\) => )(.*)/)\n        if (match?.length===3)\n          return match[2]\n      }\n      {\n        const match=fstr.match(/function\\s(\\w+)/)\n        if (match?.length===2)\n          return match[1]      \n      }\n      return\n    }()\n    try {\n      const ret=f()\n      const effective_v=v??true\n      const resolved = await resolve_maybe_promise(ret)\n      if (resolved===effective_v){\n        console.log(`\u2705 ${ek}: ${green}${effective_v}${reset}`)\n        passed++\n      } else {\n        console.error(`\u274C ${ek}:expected ${yellow}${effective_v}${reset}, got ${red}${resolved}${reset}`)\n        failed++\n      }\n    } catch (err) {\n      console.error(`\uD83D\uDCA5 ${ek} threw an error:`, err)\n      failed++\n    }\n  }\n  if (failed===0)\n    console.log(`\\nSummary:  all ${passed} passed`)  \n  else\n    console.log(`\\nSummary:  ${failed} failed, ${passed} passed`)  \n}\n\n\nexport function getCommonPrefix(paths: string[]): string {\n  if (paths.length === 0) return \"\";\n  if (paths.length === 1) return paths[0];\n\n  // Split each path into parts (e.g., by \"/\" or \"\\\\\")\n  const splitPaths = paths.map(p => p.split(/[\\\\/]+/));\n\n  const commonParts: string[] = [];\n  const first = splitPaths[0];\n\n  for (let i = 0; i < first.length; i++) {\n    const part = first[i];\n    if (splitPaths.every(p => p[i] === part)) {\n      commonParts.push(part);\n    } else {\n      break;\n    }\n  }\n\n  // Join back with \"/\" (or use path.join for platform-specific behavior)\n  return commonParts.join(\"/\");\n}\n\n\nasync function get_node(){\n  if (typeof window !== \"undefined\") {\n    throw new Error(\"getFileContents() requires Node.js\");\n  }\n  const path = await import(\"node:path\");\n  const fs = await import(\"node:fs/promises\");\n  return {fs,path}  \n}\nexport async function mkdir_write_file(filePath:string,data:string){\n  const {path,fs}=await get_node()\n  const directory=path.dirname(filePath);\n  try{\n    await fs.mkdir(directory,{recursive:true});\n    await fs.writeFile(filePath,data);\n    console.log(`File '${filePath}' has been written successfully.`);\n  } catch (err){\n    console.error('Error writing file',err)\n  }\n}\nexport async function read_json_object(filename:string,object_type:string){\n  const {fs}=await get_node()\n  try{\n    const data=await fs.readFile(filename, \"utf-8\");\n    const ans=JSON.parse(data) as unknown\n    if (!is_object(ans))\n      throw `not a valid ${object_type}`\n    return ans\n  }catch(ex:unknown){\n    console.warn(`${filename}:${get_error(ex)}.message`)\n    return undefined\n  }\n}\nexport function is_string_array(a:unknown):a is string[]{\n  if (!Array.isArray(a))\n    return false\n  for (const x of a)\n    if (typeof x!=='string')\n      return false\n  return true  \n}\n\nexport async function sleep(ms: number) {\n  return await new Promise((resolve) => {\n    setTimeout(() => resolve(undefined), ms);\n  });\n}\nexport function default_get<T>(obj:Record<PropertyKey,T>,k:PropertyKey,maker:()=>T){\n  const exists=obj[k]\n  if (exists==null){\n    obj[k]=maker()\n  }\n  return obj[k]\n}\nexport class Repeater{\n  is_running:boolean=true\n  async repeat(f:()=>MaybePromise<void>){\n    while (this.is_running) {\n      try {\n        const result = await f();\n        console.log(result);\n      } catch (error) {\n        console.error(\"Error:\", error);\n      }\n\n      // wait before next run\n      await new Promise(resolve => setTimeout(resolve, 2000));\n    }\n  }\n}"],
  "mappings": "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",
  "names": []
}
