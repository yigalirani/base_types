{
  "version": 3,
  "sources": ["../src/test.ts", "../src/index.ts"],
  "sourcesContent": ["import { is_object, pk,run_tests,type Test,is_string_array,sleep } from './index'\nclass Hello{\n  constructor(){\n    console.log('making Hello')\n  }\n}\nfunction createSimplePromise(shouldSucceed: boolean): Promise<string> {\n  return new Promise((resolve, reject) => {\n    // Simulate an asynchronous operation, e.g., a network request or a timer\n    setTimeout(() => {\n      if (shouldSucceed) {\n        resolve(\"Operation successful!\"); // Resolve the promise with a success value\n      } else {\n        reject(new Error(\"Operation failed!\")); // Reject the promise with an error\n      }\n    }, 1000); // Simulate a 1-second delay\n  });\n}  \ntype UserOpt = { id: number; name?: string }\n// Test function to run all tests\nasync function testSleep() {\n  console.log(\"Test started...\");\n\n  const start = Date.now();\n  await sleep(1000); // sleep for 1 second\n  const end = Date.now();\n\n  console.log(`Slept for ${end - start} ms`);\n  console.log(\"Test finished.\");\n  return Math.abs(end-start-1000)<100\n}\n\nexport async function runTests() {\n  const tests:Test[]=[\n  {k:'class instance',f:()=> is_object(new Hello())},\n  {k:'Set',v:false,f:()=> is_object(new Set())},\n  {k:'Function',f:()=> is_object(() => {})},\n  {k:'Array',v:false,f:()=> is_object([1, 2, 3])},\n  {k:'Number atom',v:false,f:()=> is_object(42)},\n  {k:'String atom',v:false,f:()=> is_object('hello')},\n  {k:'Boolean atom',f:()=> !is_object(true)},\n  {k:'null',v:false,f:()=> is_object(null)},\n  {k:'undefined',v:false,f:()=> is_object(undefined)},\n  {k:'Date',f:()=> is_object(new Date())},\n  {k:'RegExp',f:()=> is_object(/test/)},\n  {k:'Map',v:false,f:()=> is_object(new Map())},\n  {k:'Promise',f:()=> is_object(createSimplePromise(true))},\n  // Test cases that should return true\n  {k:'Plain object',f:()=> is_object({})},\n  {k:'Plain object with properties',f:()=> is_object({ a: 1, b: 'test' })},\n  {k:'Object created with Object.create',f:()=> is_object(Object.create({}))},\n  {k:'pk picks single key',f:()=>{\n    const user = { id: 7, name: 'Ada', active: true }\n    const pickId = pk(user, 'id')\n    return pickId.id === 7\n  }},\n  {k:'pk picks multiple keys', f:()=>{\n    const user = { id: 7, name: 'Ada', active: true }\n    const pickTwo = pk(user, 'id', 'name')\n    return pickTwo.id === 7 && pickTwo.name === 'Ada'\n  }},\n  {k:'pk returns undefined for missing optional key',f:()=>{\n    const userOpt: UserOpt = { id: 1 }\n    const pickOptional = pk(userOpt, 'name')\n    return pickOptional.name === undefined\n  }},\n  {k:'pk works with undefined source, values undefined',f:()=>{\n    const pickFromUndefined = pk<UserOpt, 'id' | 'name'>(undefined, 'id', 'name')    \n    return pickFromUndefined.id === undefined && pickFromUndefined.name === undefined\n  }},\n  {v:false,f:()=>is_string_array(null)},\n  {v:false,f:()=>is_string_array({})},\n  {v:true,f:()=>is_string_array([])},\n  {v:true,f:()=>is_string_array(['hello'])},\n  {v:true,f:()=>is_string_array(['hello','1'])},\n  {v:false,f:()=>is_string_array(['hello',1])},\n  {v:true,f:testSleep}  \n  ]\n  await run_tests(...tests)\n}\n\n// Run tests if this file is executed directly\nif (typeof require !== 'undefined' && require.main === module) {\n  void runTests()\n}\n\n\n", "export type s2t<T> = Record<string, T>\nexport type s2u = Record<string, unknown>\nexport type p2u = Record<PropertyKey, unknown> \nexport const green='\\x1b[40m\\x1b[32m'\nexport const red='\\x1b[40m\\x1b[31m'\nexport const yellow='\\x1b[40m\\x1b[33m'\n\nexport const reset='\\x1b[0m'\nexport function nl<T>(value: T | null | undefined): T {\n  //todo:check only active on debug mode\n  //return value\n  if (value === null || value === undefined) {\n    throw new Error('Value cannot be null or undefined')\n  }\n  return value\n}\nexport type Key = number | string //should i use properykey for this?\nexport type Atom = number | string | boolean \nexport function is_atom(x: unknown): x is Atom {\n  if (x == null) return false\n  return ['number', 'string', 'boolean'].includes(typeof x)\n}\nexport function is_key(x: unknown): x is Key {\n  if (x == null) return false\n  return ['number', 'string'].includes(typeof x)\n}\nexport function is_atom_ex(v: unknown, place: string, k = ''): v is Atom {\n  if (is_atom(v)) return true\n  console.warn('non-atom', place, k, v)\n  return false\n}\nexport function get_error(x:unknown){\n  if (x instanceof Error)\n    return x\n  const str = String(x)\n  return new Error(str)\n}\nexport function is_object<T extends object=s2u>(value: unknown): value is T{\n  if (value == null) return false;\n  \n  // Accept objects and functions\n  if (typeof value !== 'object' && typeof value !== 'function') return false;\n  \n  // Exclude known non-object types\n  if (Array.isArray(value)) return false;\n  if (value instanceof Set) return false;\n  if (value instanceof Map) return false;\n  \n  return true;\n}\nexport function has_key(obj: unknown, k: string): boolean {\n  if (!is_object(obj)) return false\n  return k in obj\n}\nexport function* objects_only(ar:unknown[]){\n  for (const item of ar)\n    if (is_object(item))\n      yield item\n}\n\nexport function has_keys(obj: unknown, keys: string[]): boolean {\n  if (!is_object(obj)) return false\n  for (const k of keys) if (k in keys) return true\n  return false\n}\nexport type strset = Set<string>\nexport type s2num = Record<string, number>\nexport type s2s = Record<string, string>\nexport type num2num = Record<number, number>\n\nexport function pk<T, K extends keyof T>(obj: T | undefined, ...keys: K[]): Pick<T, K> {\n  const ret: Record<PropertyKey,unknown> = {} \n  keys.forEach((key) => {\n    ret[key] = obj?.[key]\n  })\n  return ret as Pick<T, K> \n}\nexport function is_promise<T=void>(value: unknown): value is Promise<T> { ///ts(2677)\n  if (!is_object(value))\n    return false\n\n  const ans=typeof (value.then)==='function'\n  return ans\n}\ntype MaybePromise<T>=T|Promise<T>\nasync function resolve_maybe_promise<T>(a:MaybePromise<T>){\n  if (is_promise(a))\n    return await a\n  return a\n}\n      \nexport interface Test{\n  k?:string,\n  v?:Atom,\n  f:()=>MaybePromise<Atom>\n}\n\nexport async function run_tests(...tests: Test[]) {\n  let passed = 0\n  let failed = 0\n  \n  for (const {k,v,f} of tests) {\n    const ek=function(){\n      if (k!=null)\n        return k\n      const fstr=String(f)\n      {\n        const match=fstr.match(/(\\(\\) => )(.*)/)\n        if (match?.length===3)\n          return match[2]\n      }\n      {\n        const match=fstr.match(/function\\s(\\w+)/)\n        if (match?.length===2)\n          return match[1]      \n      }\n      return\n    }()\n    try {\n      const ret=f()\n      const effective_v=v??true\n      const resolved = await resolve_maybe_promise(ret)\n      if (resolved===effective_v){\n        console.log(`\u2705 ${ek}: ${green}${effective_v}${reset}`)\n        passed++\n      } else {\n        console.error(`\u274C ${ek}:expected ${yellow}${effective_v}${reset}, got ${red}${resolved}${reset}`)\n        failed++\n      }\n    } catch (err) {\n      console.error(`\uD83D\uDCA5 ${ek} threw an error:`, err)\n      failed++\n    }\n  }\n  if (failed===0)\n    console.log(`\\nSummary:  all ${passed} passed`)  \n  else\n    console.log(`\\nSummary:  ${failed} failed, ${passed} passed`)  \n}\n\n\nexport function getCommonPrefix(paths: string[]): string {\n  if (paths.length === 0) return \"\";\n  if (paths.length === 1) return paths[0];\n\n  // Split each path into parts (e.g., by \"/\" or \"\\\\\")\n  const splitPaths = paths.map(p => p.split(/[\\\\/]+/));\n\n  const commonParts: string[] = [];\n  const first = splitPaths[0];\n\n  for (let i = 0; i < first.length; i++) {\n    const part = first[i];\n    if (splitPaths.every(p => p[i] === part)) {\n      commonParts.push(part);\n    } else {\n      break;\n    }\n  }\n\n  // Join back with \"/\" (or use path.join for platform-specific behavior)\n  return commonParts.join(\"/\");\n}\n\n\nasync function get_node(){\n  if (typeof window !== \"undefined\") {\n    throw new Error(\"getFileContents() requires Node.js\");\n  }\n  const path = await import(\"node:path\");\n  const fs = await import(\"node:fs/promises\");\n  return {fs,path}  \n}\nexport async function mkdir_write_file(filePath:string,data:string){\n  const {path,fs}=await get_node()\n  const directory=path.dirname(filePath);\n  try{\n    await fs.mkdir(directory,{recursive:true});\n    await fs.writeFile(filePath,data);\n    console.log(`File '${filePath}' has been written successfully.`);\n  } catch (err){\n    console.error('Error writing file',err)\n  }\n}\nexport async function read_json_object(filename:string,object_type:string){\n  const {fs}=await get_node()\n  try{\n    const data=await fs.readFile(filename, \"utf-8\");\n    const ans=JSON.parse(data) as unknown\n    if (!is_object(ans))\n      throw `not a valid ${object_type}`\n    return ans\n  }catch(ex:unknown){\n    console.warn(`${filename}:${get_error(ex)}.message`)\n    return undefined\n  }\n}\nexport function is_string_array(a:unknown):a is string[]{\n  if (!Array.isArray(a))\n    return false\n  for (const x of a)\n    if (typeof x!=='string')\n      return false\n  return true  \n}\n\nexport async function sleep(ms: number) {\n  return await new Promise((resolve) => {\n    setTimeout(() => resolve(undefined), ms);\n  });\n}"],
  "mappings": "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",
  "names": []
}
