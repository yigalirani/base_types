export type s2t<T> = Record<string, T>;
export type s2u = Record<string, unknown>;
export type p2u = Record<PropertyKey, unknown>;
export declare const green = "\u001B[40m\u001B[32m";
export declare const red = "\u001B[40m\u001B[31m";
export declare const yellow = "\u001B[40m\u001B[33m";
export declare const reset = "\u001B[0m";
export declare function nl<T>(value: T | null | undefined): T;
export type Key = number | string;
export type Atom = number | string | boolean;
export declare function is_atom(x: unknown): x is Atom;
export declare function is_key(x: unknown): x is Key;
export declare function is_atom_ex(v: unknown, place: string, k?: string): v is Atom;
export declare function get_error(x: unknown): Error;
export declare function is_object<T extends object = s2u>(value: unknown): value is T;
export declare function has_key(obj: unknown, k: string): boolean;
export declare function objects_only(ar: unknown[]): Generator<s2u, void, unknown>;
export declare function has_keys(obj: unknown, keys: string[]): boolean;
export type strset = Set<string>;
export type s2num = Record<string, number>;
export type s2s = Record<string, string>;
export type num2num = Record<number, number>;
export declare function pk<T, K extends keyof T>(obj: T | undefined, ...keys: K[]): Pick<T, K>;
export declare function is_promise<T = void>(value: unknown): value is Promise<T>;
type MaybePromise<T> = T | Promise<T>;
export interface Test {
    k: string;
    v?: Atom;
    f: () => MaybePromise<Atom>;
}
export declare function run_tests(...tests: Test[]): Promise<void>;
export declare function getCommonPrefix(paths: string[]): string;
export declare function mkdir_write_file(filePath: string, data: string): Promise<void>;
export declare function read_json_object(filename: string, object_type: string): Promise<s2u | undefined>;
export {};
